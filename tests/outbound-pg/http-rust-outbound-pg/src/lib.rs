#![allow(dead_code)]
use anyhow::{anyhow, Result};
use spin_sdk::{
    http::{Request, Response},
    http_component, pg,
};

// The environment variable set in `spin.toml` that points to the
// address of the Pg server that the component will write to
const DB_URL_ENV: &str = "DB_URL";

#[derive(Debug, Clone)]
struct Row {
    id: i32,
    rvarchar: String,
    rtext: String,
}

#[http_component]
fn process(req: Request) -> Result<Response> {
    match req.uri().path() {
        "/test_read_types" => test_read_types(req),
        "/pg_backend_pid" => pg_backend_pid(req),
        _ => Ok(http::Response::builder()
            .status(404)
            .body(Some("Not found".into()))?),
    }
}

fn test_read_types(_req: Request) -> Result<Response> {
    let address = std::env::var(DB_URL_ENV)?;

    let create_table_sql = r#"
        CREATE TEMPORARY TABLE test_read_types (
            id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            rvarchar varchar(40) NOT NULL,
            rtext text NOT NULL
         );
    "#;

    pg::execute(&address, create_table_sql, &[])
        .map_err(|e| anyhow!("Error executing Postgres command: {:?}", e))?;

    let insert_sql = r#"
        INSERT INTO test_read_types (rvarchar, rtext) VALUES
        (
            'rvarchar',
            'rtext'
        );
    "#;

    pg::execute(&address, insert_sql, &[])
        .map_err(|e| anyhow!("Error executing Postgres command: {:?}", e))?;

    let sql = "SELECT id, rvarchar, rtext FROM test_read_types";

    let rowset = pg::query(&address, sql, &[])
        .map_err(|e| anyhow!("Error executing Postgres command: {:?}", e))?;

    let column_summary = rowset
        .columns
        .iter()
        .map(format_col)
        .collect::<Vec<_>>()
        .join(", ");

    let mut response_lines = vec![];

    for row in rowset.rows {
        let id: i32 = (&row[0]).try_into()?;
        let rvarchar: String = (&row[1]).try_into()?;
        let rtext: String = (&row[2]).try_into()?;

        let row = Row {
            id,
            rvarchar,
            rtext,
        };

        response_lines.push(format!("row: {:#?}", row));
    }

    let response = format!(
        "Found {} rows(s) as follows:\n{}\n\n(Column info: {})\n",
        response_lines.len(),
        response_lines.join("\n"),
        column_summary,
    );

    Ok(http::Response::builder()
        .status(200)
        .body(Some(response.into()))?)
}

fn pg_backend_pid(_req: Request) -> Result<Response> {
    let address = std::env::var(DB_URL_ENV)?;
    let sql = "SELECT pg_backend_pid()";

    let get_pid = || {
        let rowset = pg::query(&address, sql, &[])
            .map_err(|e| anyhow!("Error executing Postgres query: {:?}", e))?;

        let row = &rowset.rows[0];
        i32::try_from(&row[0])
    };

    assert_eq!(get_pid()?, get_pid()?);

    let response = format!("pg_backend_pid: {}\n", get_pid()?);

    Ok(http::Response::builder()
        .status(200)
        .body(Some(response.into()))?)
}

fn format_col(column: &pg::Column) -> String {
    format!("{}:{:?}", column.name, column.data_type)
}
